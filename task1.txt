1-1. Репозитарий Git должен быть устроен так, чтобы его содержимого было 
достаточно для компиляции проекта и его запуска. Но при этом не должно 
быть ничего лишнего. 

Отсюда выводы:
- для проекта в Eclipse в Git попадают:
  - каталог src (и иные каталоги с исходниками, если таковые есть)
  - файлы .classpath, .project и подобные с настройками проекта
При этом каталоги .settings и bin в Git не вкладываются (в первом 
находятся локальные настройки Eclipse и кэши плагинов, во втором - 
откомпилированные файлы

- желательно иметь скрипт (cmd/bat для Windows или sh/bash для Linux), 
который умеет собирать программу без использования Eclipse.

1-2. Конечно же для больших проектов хранить все файлы в одном пакете (к 
тому же в пакете по-умолчанию) - признак низкой квалификации. Более того, 
с помощью пакетов вся программа делится на логические единицы.

1-3. На данном этапе не нужно стараться делать описание проекта на 
английском. Лучше сделать чуть более аккуратное и развернутое описание на 
русском. (я не призываю отказываться от английского, но если нужно 
выбирать английский язык или хорошее описание на русском, то я за второй 
вариант).

1-4. Классы именуются именами существительными. Поэтому, например, не 
MakingTask, а TaskMaker (а еще лучше, TaskFactory). И сам метод newTask 
возвращает слово (т.е. Word), а не задачу (Task). Имя, получается, выбрано 
неудачно.

1-5. В классе я обращал внимание, что лучше работу со списком слов выделить 
в отдельный класс, чтобы не читать файл каждый раз, когда идет создание 
новой задачи. Аргументы относительно экономии памяти (не храним слова) и 
относительно скорости чтения (читаем не все) в данном случае оказываются 
не очень по существу, поскольку если их учитывать, то нужно сам файл 
формировать иначе (делать индекс, позволяющий быстро находить слово по его 
номеру). Ну и константа, определяющая количество слов - явный источник 
потенциальных ошибок во время работы программы.

1-6. Там же в MakingTask делается перехват исключения и возврат значения 
null. Вообще, такое поведение нежелательно

1-7. Класс Brain. Есть такая строка:    

Dialog curDialog = new Dialog();

Тут плохо то, что, вызывая конструктор, мы подчеркиваем, что нам нужна 
именно новая копия класса. Но по своей природе (в данном случае!) класс 
Dialog является постоянным (мы же зафиксировали набор ресурсов и заменять  
его не планируем). Поэтому в таких случаях обычно делают так. В самом 
классе Dialog делают:

public static final Dialog INSTANCE = new Dialog();

а потом в других классах просто обращаются к Dialog.INSTANCE. 
Такая конструкция как раз подчеркивает, что мы хотим работать с одним и 
тем же экземпляром класса.

Если же идти дальше, то ресурсы, вообще говоря, зависят от локали (это 
параметр, определяющий язык ресурсов). Поэтому с точки зрения семантики 
нам нужна операция "дай мне набор ресурсов для такого-то языка". Поэтому в 
коде она превращается в такой фабричный метод у класса Dialog:

public static Dialog getInstance(Locale) {...}

И в точке использования вызываем, например,

Dialog.getInstance(Locale.RU)

(эти замечания про локаль - для расширения кругозора, я не считаю их 
необходимыми для данной задачи, но, кажется, что было бы небесполезным об 
этом узнать).

1-8. Там же в классе Brain. Мы пишем на Java. :) И тут принято, что имена 
методов начинаются с маленькой буквы (см. методы интерфейса InputOutput, 
реализованные в Brain).

1-9. С конечным автоматом получилось почти правильно. Предлагаю посмотреть 
на то, как используются функции, которые отвечают за действия в автомате. 
Всегда мы из текущего состояния выполняем какое-то действие, а затем 
переходим в новое состояние. Поэтому разумнее интерфейс ActiveState 
описать так:

@FunctionalInterface
interface ActiveState {
    public ActiveState doWork();
}

То есть результатом действия является новое состояние автомата. Это 
упростит код.

1-10. Таблицы реакций на ввод (например, в Brain.DoYouWant) проще делать 
через switch/case (это еще и подчеркивает однотипность действий, и 
работает быстрее)

1-11. Я не очень понял, зачем Brain реализует InputOutput. Кажется, что пока 
не удалось прочувствовать, зачем нужны интерфейсы. Попробую посоветовать 
подумать, а как научить программу работать и с консолью операционной 
системы (класс Console), и со стандартными потоками ввода-вывода 
(System.in и System.out)?

