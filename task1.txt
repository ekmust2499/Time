1-1. Репозитарий Git должен быть устроен так, чтобы его содержимого было 
достаточно для компиляции проекта и его запуска. Но при этом не должно 
быть ничего лишнего. 

Отсюда выводы:
- для проекта в Eclipse в Git попадают:
  - каталог src (и иные каталоги с исходниками, если таковые есть)
  - файлы .classpath, .project и подобные с настройками проекта
При этом каталоги .settings и bin в Git не вкладываются (в первом 
находятся локальные настройки Eclipse и кэши плагинов, во втором - 
откомпилированные файлы

- желательно иметь скрипт (cmd/bat для Windows или sh/bash для Linux), 
который умеет собирать программу без использования Eclipse.

(done)
Наблюдение: после изменения структуры проекта в .gitignore достаточно 
оставить строчку с /bin/ (остальные стали не нужны).

1-2. На данном этапе не нужно стараться делать описание проекта на 
английском. Лучше сделать чуть более аккуратное и развернутое описание на 
русском. (я не призываю отказываться от английского, но если нужно 
выбирать английский язык или хорошее описание на русском, то я за второй 
вариант).

(done)

1-4. Классы именуются именами существительными. Поэтому, например, не 
MakingTask, а TaskMaker (а еще лучше, TaskFactory). И сам метод newTask 
возвращает слово (т.е. Word), а не задачу (Task). Имя, получается, выбрано 
неудачно.

(done)

1-5. В классе я обращал внимание, что лучше работу со списком слов выделить 
в отдельный класс, чтобы не читать файл каждый раз, когда идет создание 
новой задачи. Аргументы относительно экономии памяти (не храним слова) и 
относительно скорости чтения (читаем не все) в данном случае оказываются 
не очень по существу, поскольку если их учитывать, то нужно сам файл 
формировать иначе (делать индекс, позволяющий быстро находить слово по его 
номеру). Ну и константа, определяющая количество слов - явный источник 
потенциальных ошибок во время работы программы.

(done)

Наблюдение. Несмотря на то, что код оптимизирован, было бы разумно ввести 
сущность типа StringList, которая читалась бы в методе allTasks, а затем 
использовалась в newTask. Это позволило бы кэшировать эти загруженные 
списки, а не читать их каждый раз. Ну и операции (в частности, выбор 
случайного слова) относятся именно к такой сущности (т.е. их имело бы 
смысл сделать методами).

1-6. Там же в MakingTask делается перехват исключения и возврат значения 
null. Вообще, такое поведение нежелательно

(done)

Наблюдение. Да, стало лучше. Но, во-первых, мы при изучении исключений 
разберемся, что можно сделать лучше (ведь тут печать информации об ошибке 
пользователю, никак не позволяет исправить ситуацию с ошибкой; то есть это 
не пользовательская ошибка, а ошибка самого сервиса бота). Во-вторых, 
если уж и выводить информацию об ошибке пользователю, то надо выводить ее 
через специальный метод, который выполнял бы печачть при отладке программы, 
но отключал бы ее в боевом режиме.

1-7. Класс Brain. Есть такая строка:    

Dialog curDialog = new Dialog();

Тут плохо то, что, вызывая конструктор, мы подчеркиваем, что нам нужна 
именно новая копия класса. Но по своей природе (в данном случае!) класс 
Dialog является постоянным (мы же зафиксировали набор ресурсов и заменять  
его не планируем). Поэтому в таких случаях обычно делают так. В самом 
классе Dialog делают:

public static final Dialog INSTANCE = new Dialog();

а потом в других классах просто обращаются к Dialog.INSTANCE. 
Такая конструкция как раз подчеркивает, что мы хотим работать с одним и 
тем же экземпляром класса.

Если же идти дальше, то ресурсы, вообще говоря, зависят от локали (это 
параметр, определяющий язык ресурсов). Поэтому с точки зрения семантики 
нам нужна операция "дай мне набор ресурсов для такого-то языка". Поэтому в 
коде она превращается в такой фабричный метод у класса Dialog:

public static Dialog getInstance(Locale) {...}

И в точке использования вызываем, например,

Dialog.getInstance(Locale.RU)

(эти замечания про локаль - для расширения кругозора, я не считаю их 
необходимыми для данной задачи, но, кажется, что было бы небесполезным об 
этом узнать).

(done)

1-8. Там же в классе Brain. Мы пишем на Java. :) И тут принято, что имена 
методов начинаются с маленькой буквы (см. методы интерфейса InputOutput, 
реализованные в Brain).

(done)

1-9. Таблицы реакций на ввод (например, в Brain.DoYouWant) проще делать 
через switch/case (это еще и подчеркивает однотипность действий, и 
работает быстрее)

(done)

1-11. Я не очень понял, зачем Brain реализует InputOutput. Кажется, что пока 
не удалось прочувствовать, зачем нужны интерфейсы. Попробую посоветовать 
подумать, а как научить программу работать и с консолью операционной 
системы (класс Console), и со стандартными потоками ввода-вывода 
(System.in и System.out)?

(done)