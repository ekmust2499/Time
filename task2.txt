2-1. Конечно же для больших проектов хранить все файлы в одном пакете (к 
тому же в пакете по-умолчанию) - признак низкой квалификации. Более того, 
с помощью пакетов вся программа делится на логические единицы.

2-2. В классе TaskMaker видим проблему с точки зрения дизайна.
Вопрос: в чем ответственность этого класса?
И каким бы ни был ответ, окажется, что класс решает несколько задач, 
поскольку связан со всеми видами игр. А почему? Кажется, что конкретная 
игра должна описываться своим набором классов. И, кажется, не все 
возможные "игры" (думаем о потенциале развития) удастся свести к выбору 
слов  из заранее составленного словаря.
Кажется, что это предмет для обсуждения.

2-3. В классе TaskMaker вид игры передается при помощи строки. Обычно это 
неудобно. Правильнее или использовать enum, или даже завести отдельные 
константы (например, в классах, отвечающих за конкретные игры), и 
использовать эти константы для идентификации игры.

2-4. С конечным автоматом получилось почти правильно. Предлагаю посмотреть 
на то, как используются функции, которые отвечают за действия в автомате. 
Всегда мы из текущего состояния выполняем какое-то действие, а затем 
переходим в новое состояние. Поэтому разумнее интерфейс ActiveState 
описать так:

@FunctionalInterface
interface ActiveState {
    public ActiveState doWork();
}

То есть результатом действия является новое состояние автомата. Это 
упростит код.


2-5. С вводом-выводом стало лучше. Но теперь такая проблема: представьте, 
что нужно изменить логику ввода-вывода (например, работать с сетью). Каким 
будет изменение? Править класс InOut нехорошо (ведь он уже отлажен и 
прекрасно работает с консолью). Но если напишем новый класс 
(NetworkInOut), то для его подключения придется исправить все обращения к 
InOut.INSTANCE. А их много. Вот и пример, почему плоха статическая 
зависимость.

Правильнее поступить так:
- ввести интерфейс с методами 
String input() throws IOException;
void output(String) throws IOException;
- этот интерфейс окажется реализованным в классе InOut
- в классе Brain через параметр конструктора передать нужную реализацию 
этого интерфейса (пока это InOut, потом можно будет передать 
NetworkInOut), сохранить ее в поле и затем в коде класса использовать эту 
реализацию через поле.
- в коде конструирования Brain передать нужную реализацию абстракции 
ввода-вывода.

2-6. В классе Brain можно увидеть, что в разных методах, отвечающих за 
взаимодействие с пользователем есть общие блоки (например, реакция на 
команду "о себе". Причем эта команда относится к общей логике бота, а не к 
конкретной игре. Ведь так? Так вот надо подумать, как исключить это 
дублирование, как отделить логику конкретной игры от общей логики бота, но 
при этом сохранить возможность использования и тех, и других команд 
одновременно. В частности, тут надо бы выделить методы каждой из игр в 
отдельный класс (чтобы было проще видеть функциональные блоки программы) - 
вспоминаем про инкапсуляцию, это как раз она.


